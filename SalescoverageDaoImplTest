package com.ms.datalink.globalDatalink.service;

import com.ms.datalink.globalDatalink.dto.SubmissionRequest;
import com.ms.datalink.globalDatalink.model.MetadataSourceFile;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class SubmissionService {

    // … inject RestTemplate, JwtService, etc. …

    public void processSubmission(SubmissionRequest req) {
        List<MetadataSourceFile> sourceFiles = mapToMetadataSourceFiles(req);
        sourceFiles.forEach(this::saveMetadataSourceFile);
        // continue with uploads, etc.
    }

    private List<MetadataSourceFile> mapToMetadataSourceFiles(SubmissionRequest req) {
        return req.getItems().stream()
            .flatMap(item -> {
                // 1) parse raw "A | B & C | D" → ["A","B,C","D"]
                List<String> groups = parseTargetLanguages(item.getTargetLanguage());

                // 2) for each group, build a MetadataSourceFile
                return groups.stream().map(langGroup -> {
                    MetadataSourceFile msf = new MetadataSourceFile();
                    msf.setClientid(item.getSourceAccountId());
                    // you can still lookup a specific filename if desired:
                    String fn = item.getTargetFileMap().get(langGroup);
                    msf.setFilename(fn != null ? fn : item.getFileName());
                    msf.setFiletype(item.getMimeType());
                    msf.setSource_content_id(UUID.randomUUID().toString());
                    msf.setSourceLanguage(req.getSourceLanguage());
                    msf.setTargetLanguage(langGroup);
                    return msf;
                });
            })
            .collect(Collectors.toList());
    }

    /**
     * Split on '|' first, then if a chunk contains '&' join those parts with commas.
     * e.g. "A | B & C | D" → ["A","B,C","D"]
     */
    private List<String> parseTargetLanguages(String raw) {
        if (raw == null || raw.isBlank()) {
            return Collections.emptyList();
        }

        return Arrays.stream(raw.split("\\|"))
                     .map(String::trim)
                     .filter(s -> !s.isEmpty())
                     .map(chunk -> {
                         if (chunk.contains("&")) {
                             return Arrays.stream(chunk.split("&"))
                                          .map(String::trim)
                                          .filter(t -> !t.isEmpty())
                                          .collect(Collectors.joining(","));
                         }
                         return chunk;
                     })
                     .collect(Collectors.toList());
    }

    private void saveMetadataSourceFile(MetadataSourceFile msf) {
        // your persistence logic here
    }
}
